## 🧩 一、整体关系

| 对比维度     | **服务端非功能性设计**       | **SDK非功能性设计**             |
|----------|---------------------|---------------------------|
| **设计层次** | 系统级（System Level）   | 组件级（Component Level）      |
| **关注焦点** | “服务能否持续稳定对外提供能力”    | “SDK能否稳定、可靠、易用地供开发者调用”    |
| **运行位置** | 部署在服务端（运行在服务器集群）    | 部署在客户端（运行在调用方系统中）         |
| **典型目标** | 高可用、高性能、容灾、监控、安全    | 易集成、高兼容、轻量、线程安全、幂等、健壮     |
| **主要风险** | 故障传播、容量瓶颈、安全攻击      | 调用异常、依赖冲突、资源泄漏、接口变更       |
| **度量标准** | SLA、RT、TPS、MTTR、QPS | 调用成功率、RT、异常率、线程安全性、API稳定性 |
| **设计重心** | 架构、基础设施、运维、监控       | 接口设计、异常处理、资源管理、兼容性        |

---

## 🧱 二、设计目标差异

| 服务端目标                      | SDK目标                               |
|----------------------------|-------------------------------------|
| **高可用**：即使某个节点挂掉，整体仍可提供服务。 | **高稳定性**：即使调用方异常，SDK自身不崩溃、不死锁。      |
| **高性能**：提升系统吞吐量与响应速度。      | **高性能**：避免无谓阻塞、减少对象创建、优化I/O与网络复用。   |
| **可扩展性**：支持横向扩展与集群部署。      | **可扩展性**：通过SPI、策略模式、工厂模式支持多实现适配。    |
| **安全性**：防攻击、防越权、防数据泄露。     | **安全性**：签名、加密、脱敏、配置防泄露。             |
| **可运维性**：易监控、易告警、易恢复。      | **可观测性**：提供日志、埋点、TraceId，让调用方可追踪问题。 |
| **可维护性**：低耦合、高内聚、支持持续迭代。   | **可维护性**：清晰API、良好注释、兼容旧版本。          |

---

## ⚙️ 三、从“系统设计”到“SDK设计”的落差转译

| 服务端设计关注点             | SDK对应设计点                                      |
|----------------------|-----------------------------------------------|
| **服务限流与熔断**          | SDK 需支持**调用重试、超时、熔断回退策略**（如FailFast、FailOver） |
| **服务监控与指标采集**        | SDK 需提供**调用日志、性能指标上报Hook**                    |
| **安全认证（OAuth2/JWT）** | SDK 需支持**签名生成、Token刷新、密钥管理**                  |
| **分布式一致性**           | SDK 需实现**幂等请求机制、请求去重**                        |
| **容灾与多活**            | SDK 需支持**多Endpoint切换、请求Failover策略**           |
| **多租户与隔离**           | SDK 需支持**多租户配置、线程隔离上下文**                      |
| **性能调优（连接池、异步I/O）**  | SDK 需使用**连接池复用（OkHttp）、流式I/O、异步任务模型**         |
| **可观测性（日志、Tracing）** | SDK 需**埋点TraceId、可集成调用链系统（如OpenTelemetry）**   |

---

## 🧠 四、总结一句话

> **服务端非功能性设计面向“系统稳定运行”**，是从**架构与运维视角**解决问题；
>
> **SDK非功能性设计面向“开发者体验与调用可靠性”**，是从**组件与交互契约视角**解决问题。

