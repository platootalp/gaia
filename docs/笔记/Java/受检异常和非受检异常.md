## 一、核心区别（一张表看懂）

| 特性                      | 受检异常（Checked Exception）       | 非受检异常（Unchecked Exception）                                             |
|-------------------------|-------------------------------|------------------------------------------------------------------------|
| 是否继承 `Exception`        | ✅ 是                           | ✅ 是                                                                    |
| 是否继承 `RuntimeException` | ❌ 否                           | ✅ 是                                                                    |
| 编译器是否强制处理               | ✅ 是（必须 try-catch 或 throws）    | ❌ 否                                                                    |
| 代表什么类型的问题               | **可恢复的外部问题**（如文件不存在、网络断开）     | **程序逻辑错误 or 系统故障**（如空指针、数组越界）                                          |
| 典型例子                    | `IOException`, `SQLException` | `NullPointerException`, `IllegalArgumentException`, `RuntimeException` |
| 是否应该被“预期”               | ✅ 是，调用方应处理                    | ⚠️ 可预期但通常不捕获（除特定业务异常）                                                  |

---

## 二、详细解释

### 1. ✅ 受检异常（Checked Exception）

> **编译器强制你处理的异常**。

#### 📌 特点：

- 继承自 `Exception`，但**不继承** `RuntimeException`
- 如果你不处理，**编译失败**
- 表示：**这是一种正常程序流程中可能发生的、可恢复的问题**

#### 🌰 例子：

```java
public void readFile() throws IOException {
	FileInputStream fis = new FileInputStream("not_exists.txt"); // 编译器要求你处理 IOException
	fis.read();
	fis.close();
}
```

调用者必须：

```java
try{
    readFile();
}
catch(IOException e){
	System.out.println("文件读取失败："+e.getMessage());
}
```

#### ✅ 使用场景：

- 文件读写
- 网络通信
- 数据库操作
- 外部服务调用

> 💡 设计理念：**“这个错误是正常的，你应该预料到并处理它。”**

---

### 2. ❌ 非受检异常（Unchecked Exception）

> **编译器不强制你处理的异常**。

分为两类：

#### （1）**运行时异常（RuntimeException）**

- 程序逻辑错误
- 应该在编码阶段就避免

```java
String str = null;
str.length(); // NullPointerException —— 你应该提前判空
```

常见子类：

- `NullPointerException`
- `ArrayIndexOutOfBoundsException`
- `IllegalArgumentException`
- `IllegalStateException`

#### （2）**错误（Error）**

- JVM 层面的问题，一般无法恢复
- 如 `OutOfMemoryError`, `StackOverflowError`

---

## 三、关键设计哲学对比

| 问题             | 受检异常           | 非受检异常           |
|----------------|----------------|-----------------|
| 谁该负责？          | 调用方应处理         | 开发者应在编码时避免      |
| 是 bug 吗？       | 不是，是外部环境问题     | 很可能是程序 bug      |
| 能恢复吗？          | ✅ 可以重试、提示用户、降级 | ❌ 通常不能恢复（除业务异常） |
| 该 try-catch 吗？ | ✅ 应该           | ⚠️ 仅在有意义时 catch |

---

## 四、在 SpringBoot 项目中的实际应用

你正在做的文件上传系统，涉及大量异常处理。我们来结合实际场景分析：

### ✅ 推荐做法：**将受检异常包装为非受检的业务异常**

#### ❌ 不推荐：

```java
public BizResponse upload(MultipartFile file) throws IOException {
	Files.copy(file.getInputStream(), path); // 抛 IOException
	return success();
}
```

问题：

- 强制调用方处理 `IOException`
- 和 REST API 风格不符（API 应返回 JSON，而不是抛异常）

#### ✅ 推荐：

```java
public BizResponse upload(MultipartFile file) {
	try {
		Files.copy(file.getInputStream(), path);
		return BizResponse.success();
	}
	catch (IOException e) {
		log.error("文件写入失败", e);
		throw new FileUploadException(FileUploadCodeEnum.BACKEND_FILE_WRITE_FAILED);
	}
}
```

> ✅ 将 `IOException`（受检） → 包装为 `FileUploadException`（非受检，继承 `RuntimeException`）  
> ✅ 最终由 `@ControllerAdvice` 统一返回 JSON 错误

---

## 五、什么时候该用受检异常？

| 场景               | 建议                              |
|------------------|---------------------------------|
| 普通 Web API（REST） | ❌ 不用，全部转为 `RuntimeException` 子类 |
| SDK/工具库开发        | ✅ 可用，让调用方明确处理                   |
| 批处理任务，需精细错误控制    | ✅ 可考虑                           |
| Spring 项目（主流）    | ❌ 基本不用，除非特殊需求                   |

> 📌 **现代 Java 开发趋势**：**减少受检异常的使用**，尤其是 Spring 生态中。

---

## 六、最佳实践总结

| 原则                                | 建议                                      |
|-----------------------------------|-----------------------------------------|
| ✅ 业务异常 → 继承 `RuntimeException`    | 如 `BizException`, `FileUploadException` |
| ✅ 受检异常 → 包装后抛出                    | `IOException` → `FileUploadException`   |
| ✅ 不要在 Controller 层 `throws`       | 交给 `@ControllerAdvice` 统一处理             |
| ✅ 用错误码 + 错误信息返回前端                 | 而不是抛原始异常                                |
| ✅ 日志区分：业务异常用 `WARN`，系统异常用 `ERROR` |                                         |
| ✅ 用 Javadoc 注释可能抛出的异常             | 提高可读性                                   |

---

## 七、一句话总结

> 🔥 **受检异常是“你必须处理的正常问题”，非受检异常是“你应该避免的错误或可统一处理的业务失败”**。

在你的文件上传系统中：

- 文件太大、类型不支持 → `FileUploadException`（非受检，业务异常）
- IO 失败、云服务调用失败 → 包装为 `FileUploadException`
- 空指针、数组越界 → `RuntimeException`，属于 bug，不应出现在生产环境

最终目标：**让所有异常都能被全局捕获，返回结构化错误，而不是让调用方到处写 try-catch**。

这才是企业级系统的优雅之道 ✅