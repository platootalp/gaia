## 🧱 一、Java 常用数据结构总览

| 类别      | 数据结构       | 主要实现类                                     |
|---------|------------|-------------------------------------------|
| 线性结构    | 数组         | `int[]`, `String[]`                       |
|         | 动态数组       | `ArrayList<E>`                            |
|         | 链表         | `LinkedList<E>`                           |
|         | 栈          | `Stack<E>`, `Deque<E>`                    |
|         | 队列         | `Queue<E>`, `LinkedList`, `PriorityQueue` |
|         | 双端队列       | `Deque<E>`, `ArrayDeque`                  |
| 集合（Set） | 无序不重复集合    | `HashSet<E>`                              |
|         | 有序唯一集合     | `TreeSet<E>`                              |
|         | 插入顺序集合     | `LinkedHashSet<E>`                        |
| 映射（Map） | 键值对映射      | `HashMap<K,V>`                            |
|         | 有序键值对      | `TreeMap<K,V>`                            |
|         | 插入顺序映射     | `LinkedHashMap<K,V>`                      |
| 优先级队列   | 堆          | `PriorityQueue<E>`                        |
| 字典树     | Trie       | 手动实现（标准库无）                                |
| 并查集     | Union-Find | 手动实现                                      |

---

## 📚 二、详细说明与使用场景

### 1. ✅ `ArrayList<E>` —— 动态数组

- **底层**：基于可变长数组
- **特点**：
    - 支持随机访问（`get(i)` 是 O(1)）
    - 添加/删除元素可能触发扩容或移动（尾部添加快，中间慢）
- **适用场景**：频繁读取、尾部增删
- **示例**：
  ```java
  List<Integer> list = new ArrayList<>();
  list.add(1); list.get(0);
  ```

---

### 2. ✅ `LinkedList<E>` —— 双向链表

- **底层**：节点 + 前后指针
- **特点**：
    - 头尾插入删除快（O(1)）
    - 随机访问慢（O(n)）
    - 实现了 `List` 和 `Deque`
- **适用场景**：频繁在头部/中间插入删除；当作栈或队列使用
- **示例**：
  ```java
  LinkedList<Integer> deque = new LinkedList<>();
  deque.addFirst(1); deque.removeLast();
  ```

---

### 3. ✅ `HashSet<E>` —— 哈希集合

- **底层**：基于 `HashMap` 的 key 集合
- **特点**：
    - 不允许重复元素
    - 无序（不能保证顺序）
    - 查找、插入、删除平均 O(1)
- **注意**：自定义对象需重写 `hashCode()` 和 `equals()`
- **示例**：
  ```java
  Set<String> set = new HashSet<>();
  set.add("hello"); set.contains("world");
  ```

---

### 4. ✅ `TreeSet<E>` —— 有序集合（红黑树）

- **底层**：红黑树（自平衡二叉搜索树）
- **特点**：
    - 自动排序（自然顺序或 Comparator）
    - 插入/删除/查找 O(log n)
- **适用场景**：需要有序且唯一的元素集合
- **示例**：
  ```java
  Set<Integer> sortedSet = new TreeSet<>();
  sortedSet.add(5); // 自动排序
  ```

---

### 5. ✅ `LinkedHashSet<E>` —— 记录插入顺序的 Set

- **特点**：
    - 保留插入顺序
    - 底层是 `HashSet` + 双向链表
    - 性能略低于 `HashSet`，但有顺序保障
- **示例**：
  ```java
  Set<Integer> set = new LinkedHashSet<>();
  set.add(3); set.add(1); // 遍历时顺序为 3,1
  ```

---

### 6. ✅ `HashMap<K,V>` —— 哈希表映射

- **底层**：数组 + 链表/红黑树（JDK8+）
- **特点**：
    - 存储键值对，key 不重复
    - 查找、插入、删除平均 O(1)
    - 无序
- **注意**：key 对象必须正确实现 `hashCode()` 和 `equals()`
- **示例**：
  ```java
  Map<String, Integer> map = new HashMap<>();
  map.put("a", 1); map.get("a");
  ```

---

### 7. ✅ `TreeMap<K,V>` —— 有序映射

- **底层**：红黑树
- **特点**：
    - 按 key 排序（自然序或自定义比较器）
    - 操作时间复杂度 O(log n)
- **适用场景**：需要按 key 排序访问（如范围查询）
- **示例**：
  ```java
  Map<Integer, String> map = new TreeMap<>();
  map.put(3, "three"); map.put(1, "one");
  // 遍历输出：1=one, 3=three
  ```

---

### 8. ✅ `LinkedHashMap<K,V>` —— 保持插入顺序的 Map

- **特点**：
    - 保留插入顺序（或访问顺序）
    - 底层是 `HashMap` + 双向链表
- **应用**：
    - LRU 缓存（配合 `accessOrder=true`）
- **示例**：
  ```java
  Map<String, Integer> map = new LinkedHashMap<>();
  map.put("first", 1); map.put("second", 2);
  // 遍历顺序 = 插入顺序
  ```

---

### 9. ✅ `PriorityQueue<E>` —— 优先队列（堆）

- **底层**：小顶堆（默认）或大顶堆（通过 Comparator）
- **特点**：
    - 出队的是优先级最高（最小/最大）的元素
    - 插入和弹出都是 O(log n)
- **常用场景**：Top K 问题、Dijkstra 算法、合并 K 个有序链表
- **示例**：
  ```java
  PriorityQueue<Integer> pq = new PriorityQueue<>(); // 小根堆
  pq.offer(3); pq.offer(1); pq.poll(); // 返回 1
  ```

---

### 10. ✅ `ArrayDeque<E>` —— 双端队列（推荐代替 Stack 和 Queue）

- **底层**：循环数组
- **特点**：
    - 头尾均可插入删除（O(1)）
    - 性能优于 `LinkedList` 作为队列/栈
- **用途**：
    - 当作栈：`push()`, `pop()`
    - 当作队列：`offerLast()`, `pollFirst()`
- **示例**：
  ```java
  Deque<Integer> dq = new ArrayDeque<>();
  dq.push(1); dq.push(2); dq.pop(); // 栈行为
  ```

---

### 11. ✅ `Stack<E>` —— 栈（已过时，建议用 `Deque`）

- **特点**：后进先出（LIFO）
- **方法**：`push`, `pop`, `peek`
- ⚠️ **不推荐使用**：它是 `Vector` 的子类，线程安全但性能差
- ✅ 推荐替代：
  ```java
  Deque<Integer> stack = new ArrayDeque<>();
  stack.push(1); stack.pop();
  ```

---

### 12. ✅ 其他重要结构（手动实现）

| 结构                              | 是否内置 | 说明               |
|---------------------------------|------|------------------|
| **Trie（字典树）**                   | ❌ 否  | 用于字符串前缀匹配（如自动补全） |
| **Union-Find / Disjoint Set**   | ❌ 否  | 处理连通性问题（岛屿数量等）   |
| **Segment Tree / Fenwick Tree** | ❌ 否  | 区间查询、更新（高级算法题）   |

这些需要自己编码实现。

---

## 📊 三、选择指南：根据需求选数据结构

| 需求          | 推荐数据结构                                           |
|-------------|--------------------------------------------------|
| 存储唯一元素，快速查找 | `HashSet`                                        |
| 存储键值对，快速查找  | `HashMap`                                        |
| 要求元素有序（升序）  | `TreeSet`, `TreeMap`                             |
| 保持插入顺序      | `LinkedHashSet`, `LinkedHashMap`                 |
| 频繁随机访问      | `ArrayList`                                      |
| 频繁头尾增删      | `LinkedList`, `ArrayDeque`                       |
| 实现栈         | `ArrayDeque`                                     |
| 实现队列        | `ArrayDeque`, `PriorityQueue`                    |
| 取最小/最大元素    | `PriorityQueue`                                  |
| 实现 LRU 缓存   | `LinkedHashMap`（开启 accessOrder）或手写双向链表 + HashMap |

---

## ✅ 四、总结：Java 常见数据结构速查表

| 结构              | 有序性    | 重复    | 时间复杂度（平均）             | 典型用途     |
|-----------------|--------|-------|-----------------------|----------|
| `ArrayList`     | 插入序    | ✅ 允许  | get: O(1), add: O(1)* | 列表存储     |
| `LinkedList`    | 插入序    | ✅ 允许  | add/remove头尾: O(1)    | 频繁插入删除   |
| `HashSet`       | 无序     | ❌ 去重  | add/contains: O(1)    | 去重、查存在   |
| `TreeSet`       | 排序     | ❌ 去重  | O(log n)              | 有序集合     |
| `LinkedHashSet` | 插入序    | ❌ 去重  | O(1)                  | 记录顺序去重   |
| `HashMap`       | 无序     | key去重 | get/put: O(1)         | 键值映射     |
| `TreeMap`       | key排序  | key去重 | O(log n)              | 有序映射     |
| `LinkedHashMap` | 插入/访问序 | key去重 | O(1)                  | LRU、记录顺序 |
| `PriorityQueue` | 堆序     | ✅ 允许  | offer/poll: O(log n)  | Top K、调度 |
| `ArrayDeque`    | 插入序    | ✅ 允许  | push/pop: O(1)        | 栈、队列     |

> 💡 提示：大多数情况下优先使用 `ArrayList`, `HashMap`, `HashSet`, `ArrayDeque`, `PriorityQueue`
