## ✅ 一、Trie（字典树）—— 字符串前缀匹配

### 📌 用途：

- 自动补全（搜索框）
- 拼写检查
- 单词查找
- [LeetCode 208] 实现 Trie (前缀树)

```java
/**
 * 字典树（Trie）
 */
public class Trie {
    private final TrieNode root;

    static class TrieNode {
        TrieNode[] children = new TrieNode[26]; // 假设只有小写字母 a-z
        boolean isEnd; // 标记是否是一个完整单词的结尾
    }

    public Trie() {
        this.root = new TrieNode();
    }

    /**
     * 插入一个单词
     */
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }

    /**
     * 查找单词是否存在
     */
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd;
    }

    /**
     * 判断是否有以该前缀开头的单词
     */
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private TrieNode searchPrefix(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return null;
            }
            node = node.children[idx];
        }
        return node;
    }

    // 测试
    public static void main(String[] args) {
        Trie trie = new Trie();
        trie.insert("apple");
        System.out.println(trie.search("apple"));   // true
        System.out.println(trie.search("app"));     // false
        System.out.println(trie.startsWith("app")); // true
        trie.insert("app");
        System.out.println(trie.search("app"));     // true
    }
}
```

> 💡 扩展：支持所有字符？可用 `Map<Character, TrieNode>` 替代数组。

---

## ✅ 二、Union-Find（并查集）—— 联通性问题

```java
/**
 * 并查集（Union-Find / Disjoint Set Union, DSU）
 */
public class UnionFind {
    private final int[] parent;
    private final int[] rank;
    private int count;

    public UnionFind(int n) {
        this.count = n;
        this.parent = new int[n];
        this.rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    /**
     * 查找根节点（带路径压缩）
     */
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    /**
     * 合并两个集合（按秩合并）
     */
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return;

        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        count--;
    }

    /**
     * 是否连通
     */
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }

    /**
     * 获取连通分量数量
     */
    public int getCount() {
        return count;
    }

    /**
     * 获取某个元素所在集合的大小（需额外维护 size 数组才准确）
     * 这里只是返回根节点的 rank（近似值）
     */
    public int getSize(int x) {
        int root = find(x);
        return rank[root]; // 注意：这不是精确大小，仅作参考
    }

    // 测试
    public static void main(String[] args) {
        UnionFind uf = new UnionFind(10); // 创建 10 个节点：0 ~ 9

        // 构建第一个连通分量：0-1-2
        uf.union(0, 1);
        uf.union(1, 2);

        // 第二个连通分量：3-4
        uf.union(3, 4);

        // 第三个连通分量：5-6-7-8-9
        uf.union(5, 6);
        uf.union(6, 7);
        uf.union(7, 8);
        uf.union(8, 9);

        System.out.println("0 和 2 连通: " + uf.connected(0, 2));     // true
        System.out.println("0 和 9 连通: " + uf.connected(0, 9));     // false
        System.out.println("连通分量个数: " + uf.getCount());          // 应该是 3

        // 再连接一下试试
        uf.union(2, 3); // 把 0-1-2 和 3-4 连起来 → 现在 0,1,2,3,4 连通
        System.out.println("0 和 4 连通: " + uf.connected(0, 4));     // true
        System.out.println("连通分量个数: " + uf.getCount());          // 应该是 2
    }
}
```

> 🔍 提示：若要精确统计每个集合大小，可用 `size[]` 数组代替 `rank[]`，或同时维护两者。

---

## ✅ 三、Fenwick Tree（树状数组 / BIT）

### 📌 用途：

- 动态前缀和查询
- 单点更新 + 区间查询（如逆序对）
- 时间复杂度：O(log n) 更新与查询
- 空间紧凑，代码短

```java
/**
 * 树状数组（Fenwick Tree / Binary Indexed Tree）
 * 支持单点更新和前缀和查询
 */
public class FenwickTree {
    private final int[] tree;
    private final int n;

    public FenwickTree(int size) {
        this.n = size + 1; // 下标从1开始
        this.tree = new int[n];
    }

    /**
     * lowbit: 取二进制最低位的1
     */
    private int lowbit(int x) {
        return x & (-x);
    }

    /**
     * 在位置 i 上增加 delta（i 从 1 开始）
     */
    public void update(int i, int delta) {
        while (i < n) {
            tree[i] += delta;
            i += lowbit(i);
        }
    }

    /**
     * 查询前缀和 [1, i]
     */
    public int query(int i) {
        int sum = 0;
        while (i > 0) {
            sum += tree[i];
            i -= lowbit(i);
        }
        return sum;
    }

    /**
     * 查询区间和 [left, right]（闭区间，下标从1起）
     */
    public int rangeQuery(int left, int right) {
        return query(right) - query(left - 1);
    }

    // 测试
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11};
        FenwickTree ft = new FenwickTree(arr.length);

        // 初始化
        for (int i = 0; i < arr.length; i++) {
            ft.update(i + 1, arr[i]);
        }

        System.out.println("前缀和[1~3]: " + ft.query(3));           // 1+3+5=9
        System.out.println("区间和[2~4]: " + ft.rangeQuery(2, 4));   // 3+5+7=15

        ft.update(3, 2); // 给第3个数加2 → 5→7
        System.out.println("更新后区间和[2~4]: " + ft.rangeQuery(2, 4)); // 3+7+7=17
    }
}
```

> ⚠️ 注意：通常输入数组索引从 1 开始处理更方便。

---

## ✅ 四、Segment Tree（线段树）

### 📌 用途：

- 区间查询（最大值、最小值、和等）
- 支持区间更新（懒标记）、单点更新
- 更灵活但代码较长

这里实现一个基础版本：**支持区间求和 + 单点更新**

```java
/**
 * 线段树（Segment Tree）—— 区间和查询 + 单点更新
 */
public class SegmentTree {
    private final int[] tree; // 存储线段树节点值
    private final int n;

    public SegmentTree(int[] arr) {
        this.n = arr.length;
        this.tree = new int[4 * n]; // 一般开 4 倍空间
        build(arr, 0, 0, n - 1);
    }

    /**
     * 构建线段树
     * node: 当前节点编号
     * start, end: 当前节点表示的区间
     */
    private void build(int[] arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = start + (end - start) / 2;
            int leftNode = 2 * node + 1;
            int rightNode = 2 * node + 2;

            build(arr, leftNode, start, mid);
            build(arr, rightNode, mid + 1, end);
            tree[node] = tree[leftNode] + tree[rightNode];
        }
    }

    /**
     * 更新单点值：arr[index] += delta
     */
    public void update(int index, int delta) {
        update(0, 0, n - 1, index, delta);
    }

    private void update(int node, int start, int end, int idx, int delta) {
        if (start == end) {
            tree[node] += delta;
        } else {
            int mid = start + (end - start) / 2;
            if (idx <= mid) {
                update(2 * node + 1, start, mid, idx, delta);
            } else {
                update(2 * node + 2, mid + 1, end, idx, delta);
            }
            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
        }
    }

    /**
     * 查询区间和 [left, right]
     */
    public int query(int left, int right) {
        return query(0, 0, n - 1, left, right);
    }

    private int query(int node, int start, int end, int L, int R) {
        if (R < start || L > end) return 0;
        if (L <= start && end <= R) return tree[node];

        int mid = start + (end - start) / 2;
        int leftSum = query(2 * node + 1, start, mid, L, R);
        int rightSum = query(2 * node + 2, mid + 1, end, L, R);
        return leftSum + rightSum;
    }

    // 测试
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11};
        SegmentTree st = new SegmentTree(arr);

        System.out.println("初始[1~3]和: " + st.query(1, 3)); // 3+5+7=15
        st.update(2, 2); // 第2个位置（即 arr[2]=5）加2 → 变成7
        System.out.println("更新后[1~3]和: " + st.query(1, 3)); // 3+7+7=17
    }
}
```

> 🔧 进阶可扩展：
> - 支持懒标记（Lazy Propagation）实现区间更新
> - 改为维护最大值/最小值/众数等

---

## 📊 四大数据结构对比总结

| 结构               | 主要用途        | 时间复杂度（典型操作）                | 是否内置   |
|------------------|-------------|----------------------------|--------|
| **Trie**         | 字符串前缀匹配     | 插入/查询: O(L), L=字符串长度       | ❌ 手动实现 |
| **UnionFind**    | 联通性、动态连通分量  | find/union: O(α(n)) ≈ O(1) | ❌ 手动实现 |
| **Fenwick Tree** | 前缀和、逆序对     | 更新/查询: O(log n)            | ❌ 手动实现 |
| **Segment Tree** | 区间最值/和、范围查询 | 构建 O(n), 查询/更新 O(log n)    | ❌ 手动实现 |

---

## ✅ 使用建议

| 场景            | 推荐结构                            |
|---------------|---------------------------------|
| 统计逆序对         | `Fenwick Tree`                  |
| 动态前缀和         | `Fenwick Tree` 或 `Segment Tree` |
| 区间最值查询        | `Segment Tree`                  |
| 字符串前缀搜索       | `Trie`                          |
| 判断连通性（岛屿、朋友圈） | `UnionFind`                     |

---

## 🎯 总结

- `Trie`：字符串前缀神器
- `UnionFind`：处理图连通性
- `Fenwick Tree`：高效前缀和
- `Segment Tree`：强大区间查询
