## 二分查找
当然可以！以下是针对**升序数组**的六种常见二分查找类型的完整 Java 代码示例，均采用 **左闭右闭区间**（`[left, right]`）写法，循环条件为 `while (left <= right)`，并统一返回 **下标**（越界时返回 `arr.length` 或 `-1` 视情况而定）。



### ✅ 真正的“基本方法”（原子操作）

在升序数组中，最基础、不可再简化的二分查找操作是：

1. **`lowerBound(arr, target)`**  
   → 找第一个 **≥ target** 的位置  
   → 本质：**满足条件 `arr[i] >= target` 的最小下标**

2. **`upperBound(arr, target)`**  
   → 找第一个 **> target** 的位置  
   → 本质：**满足条件 `arr[i] > target` 的最小下标**

> 这两个方法在 C++ STL 中分别叫 `lower_bound` 和 `upper_bound`，是标准库的核心。

---

### 🔁 其他变体均可由基本方法推导

| 变体 | 实现方式 | 说明 |
|------|--------|------|
| **第一个等于 target** | `int i = lowerBound(arr, target); if (i < n && arr[i] == target) return i; else -1;` | 利用 lowerBound |
| **最后一个等于 target** | `int i = upperBound(arr, target) - 1; if (i >= 0 && arr[i] == target) return i; else -1;` | 利用 upperBound |
| **最后一个 ≤ target** | `upperBound(arr, target) - 1` | 因为 upperBound 是第一个 > target 的位置，前一个就是最后一个 ≤ 的 |
| **最后一个 < target** | `lowerBound(arr, target) - 1` | 因为 lowerBound 是第一个 ≥ target 的位置，前一个就是最后一个 < 的 |

> 所以你代码中：
> - `firstEqual` 调用 `lowerBound` ✅
> - `lastEqual` 调用 `lastLessEqual`（而 `lastLessEqual` 本质等价于 `upperBound - 1`）✅  
    >   但更直接的方式是：`lastEqual = upperBound(arr, target) - 1`（再校验值）

---

### 🧠 为什么这两个是“基本”的？

因为它们的**判定条件是单向的、单调的**，且**返回的是“插入位置”**，具有良好的数学性质：

- `lowerBound`：插入 `target` 后保持有序的最左位置
- `upperBound`：插入 `target` 后保持有序的最右位置

而“等于”、“小于”等操作，本质上是对这两个边界进行**后处理（验证或偏移）**。

---

### ✅ 推荐写法（更简洁、复用性高）

你可以进一步优化你的类，让逻辑更清晰：

```java
public static int firstEqual(int[] arr, int target) {
    int idx = lowerBound(arr, target);
    return (idx < arr.length && arr[idx] == target) ? idx : -1;
}

public static int lastEqual(int[] arr, int target) {
    int idx = upperBound(arr, target) - 1;
    return (idx >= 0 && arr[idx] == target) ? idx : -1;
}

public static int lastLessEqual(int[] arr, long target) {
    return upperBound(arr, target) - 1;
}

public static int lastLess(int[] arr, long target) {
    return lowerBound(arr, target) - 1;
}
```

这样：
- **只保留 `lowerBound` 和 `upperBound` 的完整二分实现**
- 其他方法变成 **一行逻辑 + 边界检查**
- 代码更短、更不容易出错、更易维护

---

### 💡 总结

| 类型 | 是否基本方法 | 建议实现方式 |
|------|-------------|-------------|
| `lowerBound`（≥） | ✅ 是 | 独立二分 |
| `upperBound`（>） | ✅ 是 | 独立二分 |
| `firstEqual`（== 首次） | ❌ 否 | `lowerBound` + 校验 |
| `lastEqual`（== 末次） | ❌ 否 | `upperBound - 1` + 校验 |
| `lastLessEqual`（≤） | ❌ 否 | `upperBound - 1` |
| `lastLess`（<） | ❌ 否 | `lowerBound - 1` |

> ✅ **记住：掌握 `lowerBound` 和 `upperBound`，就掌握了 90% 的二分查找场景。**

你的当前代码已经体现了这一思想（尤其是 `firstEqual` 直接调用 `lowerBound`），非常棒！只需把 `lastEqual` 也改为基于 `upperBound`，就更标准了。