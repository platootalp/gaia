# leetcode3289. 数字小镇中的捣蛋鬼
---

## 问题

数字小镇 Digitville 中，存在一个数字列表 nums，其中包含从 0 到 n - 1 的整数。每个数字本应 只出现一次，然而，有 两个
顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。

为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。

返回一个长度为 2 的数组，包含这两个数字（顺序任意）。

示例 1：

输入： nums = [0,1,1,0]

输出： [0,1]

解释：

数字 0 和 1 分别在数组中出现了两次。

示例 2：

输入： nums = [0,3,2,1,3,2]

输出： [2,3]

解释:

数字 2 和 3 分别在数组中出现了两次。

示例 3：

输入： nums = [7,1,5,4,3,4,6,0,9,5,8,2]

输出： [4,5]

解释:

数字 4 和 5 分别在数组中出现了两次。

提示：

2 <= n <= 100
nums.length == n + 2
0 <= nums[i] < n
输入保证 nums 中 恰好 包含两个重复的元素。

## 🎯 问题回顾

- 有一个数组 `nums`，长度为 `n + 2`
- 正常应包含 `0` 到 `n−1` 各出现 **1 次**
- 但有两个数字 `a` 和 `b` 各**多出现了一次** → 所以它们在 `nums` 中出现 **2 次**
- 其他数字仍只出现 1 次
- 目标：找出 `a` 和 `b`

> 例如：`n = 4`，正常是 `[0,1,2,3]`，但 `nums = [0,1,2,3,2,3]` → 重复的是 `2` 和 `3`

---

## 🔑 核心思想：利用 **异或（XOR）的性质**

异或有三个关键性质：

1. **自反性**：`x ^ x = 0`
2. **恒等性**：`x ^ 0 = x`
3. **交换律 & 结合律**：顺序不影响结果

👉 所以，**如果一个数出现偶数次，异或后会抵消为 0；出现奇数次，相当于只留一个。**

---

## 第一步：计算 `a ^ b`

我们来对**整个系统**做一次异或：

### 构造两个集合：

- **集合 A**：`nums` 中的所有数字（长度 n+2）
- **集合 B**：理想的 `0` 到 `n−1`（每个出现一次）

现在，我们把 **A 和 B 中所有数字全部异或在一起**：

```python
xor_all = (nums[0] ^ nums[1] ^ ... ^ nums[n+1]) ^ (0 ^ 1 ^ ... ^ (n-1))
```

### 会发生什么？

- 对于**非 a、非 b 的数字**（比如 5）：
    - 在 `nums` 中出现 1 次
    - 在理想集合中也出现 1 次
    - 所以总共异或了 **两次** → `5 ^ 5 = 0` → 抵消！

- 对于 `a`：
    - 在 `nums` 中出现 **2 次**
    - 在理想集合中出现 **1 次**
    - 总共异或了 **3 次** → 相当于 `a ^ a ^ a = (a ^ a) ^ a = 0 ^ a = a`

- 同理，`b` 也异或了 3 次 → 最后剩 `b`

✅ 所以最终：
> **xor_all = a ^ b**

> 🎉 这一步非常关键：我们得到了 `a` 和 `b` 的异或值！

---

## 第二步：如何从 `a ^ b` 分离出 `a` 和 `b`？

问题来了：知道 `a ^ b`，怎么得到 `a` 和 `b` 本身？

💡 关键观察：**因为 a ≠ b，所以 a ^ b ≠ 0**  
→ 说明 `a` 和 `b` 在**至少某一个二进制位上不同**（一个 0，一个 1）

### 举个例子：

- `a = 2` → `10`
- `b = 3` → `11`
- `a ^ b = 01` → 最低位（第 0 位）是 1 → 说明 `a` 和 `b` 在这一位不同

### 我们就选这样一个“不同的位”来分组！

通常选**最低位的 1**，可以用技巧：

```python
diff_bit = xor_all & (-xor_all)
```

这个操作能提取出 `xor_all` 的最低位 1。

例如：

- `xor_all = 6` → 二进制 `110`
- `-xor_all`（补码）→ `...010`（在二进制中，`x & -x` 得到最低位 1）
- `6 & -6 = 2` → 二进制 `010` → 表示第 1 位不同

---

## 第三步：按这一位分组异或

我们将**所有数字**（包括 `nums` 和理想集合 `0..n-1`）分成两组：

- **组 1**：该位为 1 的数字
- **组 2**：该位为 0 的数字

### 为什么这样分？

- 因为 `a` 和 `b` 在这一位**不同**，所以它们**一定分在不同组**
- 而其他数字（非 a、非 b）在 `nums` 和理想集合中各出现一次 → **总共两次**，且值相同 → 会分在同一组 → 异或后抵消！

### 于是：

- 在 `a` 所在的那一组，所有其他数字都抵消了，只剩 `a`
- 在 `b` 所在的那一组，只剩 `b`

所以我们只需对其中一组做异或，就能得到 `a`（或 `b`），另一个用 `xor_all ^ a` 得到。

---

## 🧪 举个完整例子

**输入**：`nums = [0, 3, 2, 1, 3, 2]`  
→ 长度 6 → `n = 4` → 理想集合：`[0,1,2,3]`  
→ 重复的是 `2` 和 `3`

### Step 1: 计算 `xor_all = a ^ b`

```python
# 异或 nums
0 ^ 3 ^ 2 ^ 1 ^ 3 ^ 2 = (0) ^ (3^3) ^ (2^2) ^ 1 = 0 ^ 0 ^ 0 ^ 1 = 1

# 异或理想集合 0..3
0 ^ 1 ^ 2 ^ 3 = 0

# xor_all = 1 ^ 0 = 1
```

→ `xor_all = 1` → 二进制 `01` → `a ^ b = 1`

确实：`2 ^ 3 = 10 ^ 11 = 01 = 1` ✅

### Step 2: 找不同位

```python
diff_bit = 1 & (-1) = 1  # 最低位为 1
```

### Step 3: 分组异或（只对“该位为 1”的数异或）

哪些数的**最低位是 1**？即奇数：`1, 3`

- 在 `nums` 中：`3, 1, 3` → 出现三次？不，我们遍历所有：
    - `0` → 0 → 不选
    - `3` → 1 → 选 → xor ^= 3
    - `2` → 0 → 不选
    - `1` → 1 → 选 → xor ^= 1 → 现在是 `3^1=2`
    - `3` → 1 → 选 → xor ^= 3 → `2^3=1`
    - `2` → 0 → 不选
- 在理想集合 `0,1,2,3` 中：
    - `1` → 选 → xor ^= 1 → `1^1=0`
    - `3` → 选 → xor ^= 3 → `0^3=3`

最终 `a = 3`

然后 `b = xor_all ^ a = 1 ^ 3 = 2`

✅ 得到 `[3, 2]`，正确！

---

## 🧠 为什么这个方法不依赖“出现次数是2”？

其实关键在于：

- 每个正常数字在 `nums` 和理想集合中**总共出现 2 次** → 抵消
- `a` 和 `b` 各出现 **3 次**（nums 中 2 次 + 理想中 1 次）→ 相当于**奇数次** → 不抵消

所以异或后只剩下 `a ^ b`

---

## ✅ 总结步骤

1. **计算 `xor_all = XOR(nums) ^ XOR(0..n-1)` → 得到 `a ^ b`**
2. **找 `a ^ b` 中任意一个为 1 的位（如最低位）→ `diff_bit`**
3. **遍历所有数字（nums + 0..n-1），只对 `x & diff_bit != 0` 的做异或 → 得到 `a`**
4. **`b = xor_all ^ a`**
5. **返回 `[a, b]`**

---

## 💡 优点

- 时间 O(n)，空间 O(1)
- 不怕整数溢出（不像数学法）
- 不修改原数组
- 纯位运算，高效优雅

非常好的问题！我们来**一步步讲清楚**：  
为什么 `-6` 的二进制（在补码表示下）与 `6` 进行按位与（`6 & -6`）能得到最低位的 1（即 `2`，二进制 `010`）。

---

## 🔢 背景：计算机中负数用「补码」表示

在现代计算机（包括 Python、Java、C++ 等）中，**负整数是以「二进制补码」（Two's Complement）形式存储的**。

### 补码的计算规则：

对一个正整数 `x`，其负数 `-x` 的补码为：
> **-x = (~x) + 1**  
> （即：先按位取反，再加 1）

---

## 🧮 以 `x = 6` 为例

### 第 1 步：写出 `6` 的二进制（假设用 8 位演示，实际在 Python 中是任意精度）

```
6 = 0000 0110
```

### 第 2 步：按位取反 `~6`

```
~6 = 1111 1001
```

### 第 3 步：加 1 得到 `-6`

```
   1111 1001
+          1
------------
   1111 1010
```

所以：
> **-6 的二进制补码是 `1111 1010`**

---

## 🔍 现在计算 `6 & -6`

```
     6 = 0000 0110
   -6 = 1111 1010
------------------ (按位 AND)
6 & -6 = 0000 0010
```

结果是 `0000 0010`，即 **十进制的 2**！

而这正好是 `6`（`110`）中**最低位的 1 所代表的值**（第 1 位，从 0 开始数，值为 2¹ = 2）。

✅ 所以：
> **`x & -x` 的作用是：提取 `x` 的二进制表示中最低位的 1，其余位清零。**

---

## 🌟 为什么这个技巧成立？（直观理解）

设 `x` 的二进制形式为：

```
x = A1000...0   （A 是任意前缀，后面跟着 k 个 0，最低位的 1 在第 k 位）
```

那么：

- `~x = (~A)0111...1`
- `-x = (~x) + 1 = (~A)1000...0`

所以 `x` 和 `-x` 的共同点是：**只有最低位的 1 及其后面的 0 是对齐的**，而前面的位相反。

做 `x & -x` 时：

- 前面的位：`A & (~A) = 0`
- 最低位的 1：`1 & 1 = 1`
- 后面的 0：`0 & 0 = 0`

结果就是：**只有最低位的 1 保留，其余为 0**。

---

## 📌 在本题中的用途

我们有 `xor_all = a ^ b`，且 `a ≠ b` → `xor_all ≠ 0`  
→ 它至少有一个位是 1，说明 `a` 和 `b` 在该位不同。

用 `diff_bit = xor_all & (-xor_all)` 就能**快速找到这样一个不同的位**（最低位即可），用于后续分组。

---

## 💡 补充：Python 中的整数是「任意精度」的

在 Python 中，整数没有固定位数（不像 C++ 的 32 位 int），但**补码逻辑依然适用**，因为 Python 在底层对负数也使用类似的无限位补码表示。

所以即使你写：

```python
>>> 6 & -6
2
>>> 12 & -12
4
>>> 10 & -10
2
```

结果都正确！

---

## ✅ 总结

| 操作       | 含义                                        |
|----------|-------------------------------------------|
| `-x`     | 在补码系统中 = `(~x) + 1`                       |
| `x & -x` | 提取 `x` 的最低位 1 对应的值（如 `6 (110) → 2 (010)`） |
| 用途       | 快速找到两个不同数（`a`, `b`）在二进制中**第一个不同的位**       |

这个技巧在位运算题目中非常经典，比如：

- 找出只出现一次的数
- 分离两个不同的数
- 树状数组（Fenwick Tree）的实现

希望这次彻底讲明白了！如果还想看其他例子（比如 `x=12`），欢迎继续问 😊