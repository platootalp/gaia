# 系统设计 — 概要指南（适合工程实践与面试）

下面把系统设计的知识和技术按体系化、实践化的方式讲清楚：从设计流程、常见架构模式、关键能力点（可用性、扩展性、性能、安全等）、数据与存储、分布式问题、可靠性、运维/可观测性，到落地细节与面试要点。尽量给出可落地的建议和设计决策要点，便于在真实项目中权衡与实现。

---

## 一、系统设计的基本流程（建议的步骤）

1. **明确目标与约束**

    * 业务目标（功能、用户故事、核心场景）
    * 非功能需求（QPS、延迟、可用性、存储、成本、合规）
    * 有哪些硬约束（如数据驻留、法规、兼容遗留系统等）

2. **定义关键用例与容量估算**

    * 列出核心请求路径（读/写、批处理、离线任务）
    * 估算QPS/并发/数据量/增长率（按峰值和平均分开计算）
    * 计算存储、带宽、CPU、延迟预算

3. **高层架构草图**（组件与边界）

    * 单体/微服务/模块化单体的选择理由
    * 外部依赖（DB、缓存、消息队列、第三方API、CDN）

4. **关键设计决策（热备/容灾/一致性/分区等）**

    * 说明为什么选某种数据库、消息系统、缓存策略
    * 设计可伸缩路径和演进策略

5. **详细设计与接口定义**

    * API 设计（接口、幂等、版本化、认证）
    * 数据模型、索引、事务边界

6. **容错、监控、运维方案**

    * 异常场景设计（重试、熔断、退避、限流）
    * 日志、指标、链路追踪、告警

7. **安全与合规**

    * 身份鉴别、权限控制、加密、审计

8. **测试与演练**

    * 单元/集成/压力/Chaos（灾备演练）
    * 回滚策略与蓝绿/灰度发布

---

## 二、架构模式与何时使用

### 1. 单体（Monolith）

* 适用场景：早期、团队小、上线速度要求高
* 优势：开发速度快，部署简单
* 缺点：难扩展、发布风险大
* 建议：用模块化单体（清晰模块边界 + CI）作为过渡

### 2. 微服务（Microservices）

* 适用场景：大规模团队、复杂域、需要独立扩缩容
* 关键点：服务边界、契约、容错、分布式事务处理、运维成本
* 技术：服务注册、网关、熔断（Hystrix-like）、链路追踪

### 3. 事件驱动 / 异步架构

* 适用场景：解耦、削峰、实现最终一致性、复杂业务流程
* 关键点：消息幂等、顺序性、重放、安全、持久化
* 常用组件：Kafka、RabbitMQ、Pulsar

### 4. CQRS + 事件溯源（Command Query Responsibility Segregation）

* 适用场景：复杂业务模型、读写分离、高并发读场景
* 风险：实现复杂、调试难度高

### 5. Serverless / FaaS

* 适用场景：无状态、间歇性负载、快速迭代
* 注意：冷启动、调试、长期运行任务受限

---

## 三、关键非功能性需求（NFR）与实现策略

### 可扩展性（Scalability）

* 水平扩展优先于垂直扩展
* 无状态服务 + 共享外部状态（DB/缓存）
* 分片（Shard）与分区（Partition）设计：按用户/地域/时间分片
* 读写分离（主从复制）+ 分库分表（按数据规模与访问模式）

### 可用性与容错（Availability & Fault Tolerance）

* 多AZ/多Region部署、主动-被动/主动-主动复制
* 健康检查与自动恢复（K8s readiness/liveness）
* 重试+幂等+熔断（防止级联故障）
* 数据备份与恢复演练（RTO/RPO目标）

### 一致性 & 事务（Consistency）

* 选择一致性模型：强一致性、弱一致性或最终一致性
* 分布式事务：尽量避免 2PC，优先用 SAGA、补偿逻辑或幂等设计
* CAP 权衡：明确哪些场景优先可用，哪些必须一致

### 性能（Latency & Throughput）

* 常用手段：缓存（本地、Redis/Proxy）、异步化、批量化、索引优化、压缩/序列化优化（Protobuf）
* 网络层面：保持合理的请求/响应体大小、使用HTTP/2或gRPC在内部服务间通信

### 成本（Cost）

* 选择合适的云实例类型、预留实例或按需折中
* 存储冷热分层（冷数据搬到低成本存储）
* 权衡性能目标与成本（SLO决定资源投入）

---

## 四、数据存储（如何选数据库 & 数据模型）

### 关系型数据库（MySQL、Postgres）

* 强事务支持、复杂查询、数据一致性
* 扩展方式：读写分离、分库分表（sharding）、Proxy（Atlas、Vitess）

### NoSQL（MongoDB、Cassandra、HBase）

* 文档/列族适合灵活模式或海量写场景
* Cassandra 适合高写吞吐与高可用性

### Key-Value / 内存数据库（Redis）

* 缓存、短期会话、排行榜、延迟队列
* 注意：持久化策略、LRU、内存预估、主从故障切换

### 向量数据库（Milvus、Pinecone）

* 适用于相似度搜索、语义检索（大模型/检索场景）

### OLTP vs OLAP

* OLTP：事务、低延迟写读（用行存储DB）
* OLAP：分析、批量查询（列存储、数据仓库如ClickHouse、BigQuery）

### 设计建议

* 合理建模：以查询为中心反向设计索引
* 少用跨表JOIN（分布式JOIN成本高），对复杂分析用ETL到DW
* 保持表的热点均匀（避免单表/单分区写爆）

---

## 五、缓存策略（Cache Patterns）

* **Cache Aside（旁路缓存）**：应用先查缓存，未命中再查DB并回填。常用且灵活。需处理并发回填（Cache Stampede）
* **Read-Through / Write-Through**：缓存和DB一致性强，写入成本高
* **Write-Behind**：异步刷新到DB，注意数据丢失/顺序性
* **TTL & Cache Eviction**：设置合理 TTL，避免缓存雪崩（使用随机TTL或多级缓存）
* 预热（cold start）与热点key策略（分片、使用Local cache + shared cache）

---

## 六、消息与流式处理

* **消息队列职责**：解耦、异步、削峰
* 设计要点：可见性超时、重试策略、幂等、顺序性（按partition保证）
* 流处理（Flink、Kafka Streams）：实时分析、窗口聚合、复杂事件处理
* **Exactly-once** vs **At-least-once**：业务上选择可接受的语义并设计补偿

---

## 七、分布式系统常见问题与解决办法

* **网络分区与CAP**：清楚业务对可用性/一致性的要求
* **时钟与顺序**：使用逻辑时钟/向量时钟来处理事件顺序
* **一致性协议**：Raft、Paxos（用于leader选举、配置管理）
* **分布式锁**：只在必要时使用（Redlock有争议），优先用乐观并发控制（CAS、版本号）
* **数据重复/幂等**：请求ID、去重表、幂等操作设计

---

## 八、可靠性设计（Chaos Engineering）

* 设计容错：超时设置、并发限制、队列长度限制
* 实施演练：故障注入、流量切换演练（Blue/Green）
* SLA/SLO：定义服务级目标（错误率、P99延迟），基于SLO做告警与运维优先级

---

## 九、安全（至少包含这些）

* 身份与访问管理（OAuth2、JWT、mTLS）
* 最小权限原则、RBAC/ABAC设计
* 数据在传输/静态时加密（TLS、Field-level encryption）
* SQL注入、XSS、CSRF防护；输入校验与输出编码
* 审计日志、敏感操作审计、密钥管理（KMS）

---

## 十、可观测性（Observability）

* **指标（Metrics）**：业务指标 + 基础设施指标（QPS、错误率、延迟、队列长度）
* **日志（Logs）**：结构化日志（JSON），请求ID/trace id贯穿全链路
* **追踪（Tracing）**：分布式追踪（OpenTelemetry、Jaeger）用于定位跨服务延迟
* **告警与报表**：基于SLO设置告警，避免噪音；设置可执行的runbook

---

## 十一、部署与CI/CD

* 自动化流水线（构建、单元测试、集成测试、容器镜像、自动化部署）
* 发布策略：滚动发布、蓝绿、金丝雀（灰度）
* 配置管理：配置中心（Spring Cloud Config、Consul）、Feature Flag支持灰度控制
* 基础设施即代码（Terraform、CloudFormation）

---

## 十二、常用设计模式（摘要）

* **Circuit Breaker**（熔断）
* **Bulkhead**（隔离舱）
* **Retry with Backoff**（重试+退避）
* **Bulkhead + Thread pool**（资源隔离）
* **Sidecar**（与服务同宿主的代理）
* **Adapter / Façade / Gateway**（接口适配与接入）
* **Producer-Consumer / Work Queue**（异步处理）

---

## 十三、实践技巧与工程注意事项

* **先做可测的最小可行方案（MVP）**，再优化：先满足功能，再做扩展性设计。
* **指标驱动改进**：改架构前先量化瓶颈（profile & trace）
* **避免过早优化**：复杂方案（CQRS、ES）提前评估成本与维护性
* **保持后向兼容**：API版本化、向后兼容的schema演进（Protobuf/Avro）
* **统一错误码与可解释错误**：便于前端/客户端处理

---

## 十四、面试常见题型与答题要点（速查）

1. **设计一个短链接服务（如 bit.ly）**

    * 关键点：短码生成（base62、哈希冲突）、DB设计、缓存、重定向性能、统计计数、防刷（rate limit）
2. **设计一个图片/文件上传系统**

    * 关键点：分片上传、断点续传、CDN、预签名URL、病毒扫描、权限控制、转码/处理队列
3. **高并发下的计数器（如点赞）**

    * 关键点：用Redis计数+定期批量落地、避免热点key（hash到多槽）、弱一致性接受策略
4. **设计消息队列或任务调度系统**

    * 关键点：可见性超时、消息重试、幂等、任务分片与负载均衡
5. **如何设计一个高可用的数据库架构**

    * 关键点：主从复制、读写分离、分片策略、备份恢复、跨机房复制与延迟处理

答题时结构化回答：需求 → 约束 → 高层架构 → 关键组件设计 → 可伸缩性与容错 → 数据一致性 → 性能与成本权衡 → 安全部署与监控。

---

## 十五、实战示例（简要架构草图示例）

**在线图片服务（高并发展示、上传）示例要点：**

* 客户端上传 → API Gateway（鉴权、限流）→ Upload Service（生成 presigned URL）→ 客户端直传到对象存储（COS/S3）→
  上传完成消息进队列 → 后台处理（缩略图、转码）→ 缓存（CDN + Redis）→ 数据库保存元信息（MySQL）
* 可扩展点：对象存储分区、处理任务池、CDN边缘缓存、按地域路由

---

## 十六、常用工具与生态（工程实践参考）

* **容器与编排**：Docker + Kubernetes
* **服务网格**：Istio / Linkerd（流量控制、mTLS）
* **监控**：Prometheus + Grafana
* **日志/追踪**：ELK（Elasticsearch/Logstash/Kibana）或 Loki；Jaeger/OpenTelemetry
* **消息/流**：Kafka、RabbitMQ、Pulsar、RocketMQ
* **数据库**：MySQL/Postgres、Redis、Cassandra、ClickHouse
* **CD/CI**：Jenkins、GitHub Actions、GitLab CI、ArgoCD

---

## 十七、快速检查表（设计评审用）

* 功能需求是否完整、优先级是否明确？
* QPS/数据量估算是否合理？是否考虑增长？
* 是否画出高可用部署拓扑（多AZ/多Region）？
* 有没有单点故障？如何避免？
* 数据一致性模型是否明确？事务边界是否清楚？
* 是否做好容量规划与成本估算？
* 是否考虑了安全合规（加密、审计）？
* 是否定义了SLO/SLA及相应告警？
* 是否有回滚与灾备演练方案？
* 是否有可观测性（指标/日志/追踪）和runbook？

---

## 十八、进阶学习路径与书目（简短建议）

* 学习顺序建议：网络基础 → 操作系统与并发 → 分布式系统理论（CAP、一致性算法）→ 数据库原理 → 缓存与队列 → 架构模式 → 可观测性与运维
* 推荐书籍（经典）：《Designing Data-Intensive Applications》（Martin Kleppmann）、《Distributed Systems: Principles and
  Paradigms》、《Site Reliability Engineering》（Google SRE）等。
