### ✅ 一、异步请求需要考虑的核心问题（分类详解）

| 类别 | 问题 | 说明与应对策略 |
|----|----|---------|

---

#### 1. ✅ **状态管理与生命周期跟踪**

> 异步任务一旦发起，就不能“立即知道结果”，必须有机制跟踪其状态。

- **问题**：
    - 客户端如何知道任务是否成功？
    - 如何查询中间状态（处理中、失败、成功）？
    - 任务是否超时？

- **解决方案**：
    - ✅ 提供 `taskId` 唯一标识任务
    - ✅ 持久化任务记录（如你设计的 `media_process_task` 表）
    - ✅ 支持通过 `GET /task/{taskId}` 查询状态
    - ✅ 设置任务状态机：`PENDING → PROCESSING → SUCCESS/FAILED`
    - ✅ 记录开始时间、结束时间，用于超时判断

---

#### 2. ✅ **结果通知机制（Callback / Webhook）**

> 云服务或后台处理完成后，需主动通知调用方。

- **问题**：
    - 回调地址不可靠（网络不通、服务宕机）
    - 回调重复发送（幂等性问题）
    - 回调丢失（无确认机制）

- **解决方案**：
    - ✅ 使用 **可靠回调 + 重试机制**（如3次指数退避）
    - ✅ 回调内容包含 `taskId`、`status`、`outputPath` 等关键信息
    - ✅ 接收方必须返回 `200 OK`，否则视为失败并重试
    - ✅ 记录回调次数、回调内容、响应码（用于排查）
    - ✅ 支持回调签名验证（防伪造）

---

#### 3. ✅ **幂等性（Idempotency）**

> 同一个请求重复提交，应保证只创建一个任务。

- **问题**：
    - 用户刷新页面多次提交
    - 网络超时导致客户端重试
    - 消息队列重复消费

- **解决方案**：
    - ✅ 引入 `clientRequestId`（客户端唯一 ID）
    - ✅ 在 DB 中建立 `(client_request_id, vendor)` 唯一索引
    - ✅ 先查是否存在，存在则返回已有 `taskId`，不再重复创建
    - ✅ 或使用 Redis 缓存去重（短期幂等）

---

#### 4. ✅ **错误处理与容错机制**

> 异步任务可能失败，不能“发出去就不管”。

- **问题**：
    - 云服务返回失败
    - 参数错误、文件不存在
    - 网络抖动、超时

- **解决方案**：
    - ✅ 明确失败状态码（如 `FAILED`, `TIMEOUT`, `FILE_NOT_FOUND`）
    - ✅ 记录失败原因（error_message）
    - ✅ 支持手动重试或自动重试（有限次数）
    - ✅ 失败任务进入告警系统（如企业微信/钉钉通知）

---

#### 5. ✅ **资源清理与生命周期管理**

> 临时文件、数据库记录、缓存等不能无限堆积。

- **问题**：
    - 临时输出文件占用磁盘
    - 已完成任务长期不清理
    - 回调失败任务堆积

- **解决方案**：
    - ✅ 设置任务 TTL（如 7 天后自动归档或删除）
    - ✅ 定期清理临时文件（按 `task_create_time` 和状态）
    - ✅ 成功任务保留路径，失败任务可自动删除输出
    - ✅ 提供 `DELETE /task/{taskId}` 接口（可选）

---

#### 6. ✅ **可观测性（Observability）**

> 如何监控、排查、审计异步任务？

- **问题**：
    - 任务卡在“处理中”怎么办？
    - 回调失败了怎么发现？
    - 哪些任务失败率高？

- **解决方案**：
    - ✅ 日志结构化：记录 `taskId`, `status`, `region`, `bucket` 等字段
    - ✅ 打点监控：Prometheus + Grafana 监控任务数、成功率、耗时
    - ✅ 链路追踪：使用 SkyWalking / Zipkin 跟踪从请求到回调全过程
    - ✅ 运维后台：提供任务列表页，支持筛选、搜索、导出

---

#### 7. ✅ **并发与限流控制**

> 大量异步请求可能压垮系统。

- **问题**：
    - 瞬时高并发创建任务
    - 云厂商 API 有 QPS 限制
    - 本地线程池/数据库连接被打满

- **解决方案**：
    - ✅ 接口层限流（如 Sentinel、RateLimiter）
    - ✅ 任务队列排队（如 RabbitMQ/Kafka）
    - ✅ 分布式锁防止同一资源并发处理
    - ✅ 云厂商任务提交使用异步线程池隔离

---

#### 8. ✅ **安全性**

> 异步任务可能成为攻击入口。

- **问题**：
    - 回调 URL 被恶意利用（SSRF）
    - 输出路径被写入敏感目录
    - 参数注入（如命令执行）

- **解决方案**：
    - ✅ 校验输入文件路径合法性
    - ✅ 回调地址白名单校验
    - ✅ 输出路径沙箱限制（不能写 `/etc` 等）
    - ✅ 敏感操作需鉴权（如 OAuth2 / API Key）

---

#### 9. ✅ **跨系统一致性（分布式事务）**

> 任务创建成功，但消息未发送、或 DB 未写入。

- **问题**：
    - 任务在云平台存在，但本地没记录 → 回调找不到任务
    - 消息发了，但任务没创建 → 消费者报错

- **解决方案**：
    - ✅ 先持久化任务记录（`SUBMITTED` 状态），再提交云任务
    - ✅ 使用 **本地事务表 + 定时补偿** 机制
    - ✅ 或使用 **可靠消息**（如 RocketMQ 事务消息）

---

#### 10. ✅ **客户端体验优化**

> 异步不代表“无响应”。

- **问题**：
    - 客户端不知道后续怎么查结果
    - 没有进度提示

- **解决方案**：
    - ✅ 返回 `202 Accepted` + `taskId`
    - ✅ 提供查询接口文档
    - ✅ 支持 SSE / WebSocket 推送状态（高级）
    - ✅ 响应中包含 `location` 头：`Location: /task/{taskId}`

---

### ✅ 二、典型异步请求流程图

```text
客户端
   ↓ 发起请求（带 clientRequestId）
网关/服务
   ↓ 校验参数 + 幂等检查
   ↓ 生成 tempPath, callbackUrl
   ↓ 提交云任务 → 获取 jobId（taskId）
   ↓ 保存任务记录（SUBMITTED）
   ↓ 返回 taskId + tempPath
   ↓ 发送状态跟踪消息（MQ）
   ↘ 客户端轮询或等待回调

云平台处理中...
   ↓ 处理完成
   ↓ 回调你的 callbackUrl（带 jobId, status, outputPath）
你的服务
   ↓ 验证签名 + 更新任务状态（SUCCESS/FAILED）
   ↓ 通知客户端（可选）
```

---

### ✅ 三、总结：异步请求 checklist

| 检查项           | 是否必须     |
|---------------|----------|
| ✅ 返回 `taskId` | ✅ 必须     |
| ✅ 持久化任务记录     | ✅ 必须     |
| ✅ 支持查询任务状态    | ✅ 必须     |
| ✅ 实现回调机制      | ✅ 必须     |
| ✅ 处理回调幂等      | ✅ 必须     |
| ✅ 记录回调日志      | ✅ 推荐     |
| ✅ 支持幂等提交      | ✅ 推荐     |
| ✅ 错误码与失败原因    | ✅ 必须     |
| ✅ 超时与重试机制     | ✅ 必须     |
| ✅ 监控与告警       | ✅ 生产环境必须 |
| ✅ 资源清理策略      | ✅ 必须     |
| ✅ 安全校验        | ✅ 必须     |

---

### ✅ 四、附加建议

- 使用 **CQRS 模式**：写任务（Command）和查状态（Query）分离
- 使用 **事件驱动架构**：任务创建 → 发事件 → 更新状态 → 发通知
- 对接 **任务调度中心**：如 XXL-JOB、Airflow（适用于复杂工作流）

---

如果你正在设计一个通用的“异步任务平台”，可以进一步抽象为：

```java
interface AsyncTaskService<T> {
	AsyncTaskResponse submit(TaskRequest request);

	TaskStatus query(String taskId);

	void onCallback(CallbackData data);
}
```
