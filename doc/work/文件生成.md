# 📦 多类型测试文件生成方案（PDF / MP4 / MP3 / JPG / TXT 等）

---

## ✅ 一、目标：生成指定大小的真实格式文件

| 文件类型        | 目标大小                 | 是否真实可打开          | 工具                        |
|-------------|----------------------|------------------|---------------------------|
| `.pdf`      | 500KB, 1MB, 2MB, 3MB | ✅ 是（Acrobat 可打开） | `fpdf` (Python) / `pdftk` |
| `.mp4`      | 1MB, 2MB, 3MB, 5MB   | ✅ 是（VLC 可播放）     | `ffmpeg`                  |
| `.mp3`      | 1MB, 2MB, 5MB        | ✅ 是（可播放）         | `ffmpeg`                  |
| `.jpg/.png` | 500KB~3MB            | ✅ 是              | `ImageMagick`             |
| `.txt`      | 任意大小                 | ✅ 是              | `dd` / `echo`             |

---

## 🛠️ 二、安装依赖工具（一次性）

### Linux（Ubuntu/Debian）

```bash
sudo apt-get update
sudo apt-get install -y imagemagick ffmpeg pdftk python3-pip
pip3 install fpdf
```

### macOS（Homebrew）

```bash
brew install imagemagick ffmpeg pdftk
pip3 install fpdf
```

### Windows

- 下载并安装：
    - [ImageMagick](https://imagemagick.org/script/download.php)
    - [FFmpeg](https://www.gyan.dev/ffmpeg/builds/)
    - Python + `pip install fpdf`

---

## 🧩 三、分类型生成脚本

### 1. ✅ 生成 PDF 文件（使用 Python + FPDF）

```python
import os
from io import BytesIO
 
import numpy as np
from PIL import Image
from fpdf import FPDF
from moviepy import ImageClip, AudioArrayClip, ColorClip, VideoClip
 
 
def create_pdf_file(filename, target_kb):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
 
    # 写入内容
    content = "Performance Test File\n" * 200
    for _ in range(target_kb // 2):  # 粗略估算每 2KB 写一次
        pdf.multi_cell(0, 5, content)
 
    pdf.output(filename)
 
 
def create_png_file(filename, size_kb):
    """快速生成接近指定大小的 PNG 文件（通过估算图像尺寸）"""
    target_bytes = size_kb * 1024
 
    # 经验公式：估算 PNG 图像大小（单位：字节）
    # 大小 ≈ 像素数 * 3（RGB） * 压缩率（经验值 ~0.5~1.0），加上头部开销
    # 通过实验可得：side^2 * 1.2 ~ 1.8 是常见字节数
    # 我们用 side^2 * 1.5 来反推初始尺寸
    estimated_side = int((target_bytes / 1.5) ** 0.5)
    side = max(100, estimated_side)  # 最小尺寸
 
    # 二分查找或逼近
    low, high = 50, side * 2
    best_img = None
 
    while low <= high:
        mid = (low + high) // 2
        img = Image.new('RGB', (mid, mid), color='blue')
 
        # 使用 BytesIO 避免磁盘 I/O
        buf = BytesIO()
        img.save(buf, format='PNG')
        size = buf.tell()
 
        if size <= target_bytes:
            best_img = (img, size)
            low = mid + 1
        else:
            high = mid - 1
 
    if best_img is None:
        # 回退
        img = Image.new('RGB', (100, 100), color='blue')
        img.save(filename, format='PNG')
    else:
        img, final_size = best_img
        img.save(filename, format='PNG')
 
        # 如果还小，不推荐追加无效数据（破坏文件结构）
        # 更好的做法：接受略小，或用填充像素（比如加一行透明像素）
        if final_size < target_bytes:
            padding_needed = target_bytes - final_size
            if padding_needed > 0:
                with open(filename, 'ab') as f:
                    f.write(b'\x00' * padding_needed)
        elif os.path.getsize(filename) > target_bytes:
            with open(filename, 'r+b') as f:
                f.truncate(target_bytes)
 
    actual = os.path.getsize(filename)
    print(f"PNG 生成完成: {filename} ({actual} bytes)")
 
 
def create_mp4_file(filename, size_kb, tolerance=0.05):
    """
    生成接近指定大小的真实 MP4 文件（噪声画面 + 双轮逼近）
    :param filename: 输出文件名
    :param size_kb: 目标大小（KB）
    :param tolerance: 容差（5%）
    """
    target_bytes = size_kb * 1024
    fps = 24
    width, height = 640, 480
 
    def make_frame(t):
        return np.random.randint(0, 255, (height, width, 3), dtype=np.uint8)
 
    # 第一轮：估算合理时长
    estimated_bitrate_kbps = 800  # 假设平均码率（可调）
    duration = max(1.0, (target_bytes * 8) / (estimated_bitrate_kbps * 1024))  # 秒
 
    for attempt in range(3):  # 最多尝试 3 次
        clip = VideoClip(make_frame, duration=duration)
        clip.fps = fps
 
        # 写入文件
        if os.path.exists(filename):
            os.remove(filename)
 
        clip.write_videofile(
            filename,
            codec='libx264',
            audio=False,
            bitrate=f"{int((target_bytes * 8) / (duration * 1024))}k",  # 动态码率
            ffmpeg_params=['-preset', 'ultrafast'],
            logger=None,
            threads=1
        )
 
        actual = os.path.getsize(filename)
        error = actual - target_bytes
 
        print(f"第{attempt + 1}轮: {duration:.2f}s → {actual} bytes (目标: {target_bytes}, 差: {error:+d})")
 
        # 如果在容差范围内，成功
        if abs(error) <= target_bytes * tolerance:
            print(f"成功: {filename} ({actual} bytes)")
            return
 
        # 调整时长：按比例修正
        duration = duration * (target_bytes / actual)
 
        # 限制范围（1秒 ~ 60秒）
        duration = max(1.0, min(duration, 60.0))
 
        clip.close()  # 释放资源
 
    actual = os.path.getsize(filename)
    print(f"已尽力逼近: {filename} ({actual} bytes)")
 
 
def create_mp3_file(filename, size_kb):
    """
    生成指定大小的真实 MP3 音频文件（静音，通过调节时长控制大小）
    """
    target_bytes = size_kb * 1024
    sample_rate = 44100
    channels = 2
    # 估算：128kbps 码率 ≈ 16 KB/s
    bitrate_kbps = 128
    duration_seconds = (target_bytes * 8) / (bitrate_kbps * 1024)  # 秒
    duration_seconds = max(1, duration_seconds)
 
    # 生成静音音频数据
    duration_samples = int(duration_seconds * sample_rate)
    silent_audio = np.zeros((duration_samples, channels))  # 立体声静音
 
    audio_clip = AudioArrayClip(silent_audio, fps=sample_rate)
    audio_clip.write_audiofile(
        filename,
        codec='mp3',
        bitrate=f'{bitrate_kbps}k',
        logger=None
    )
 
    actual = os.path.getsize(filename)
    print(f"真实 MP3 生成: {filename} ({actual} bytes)")
 
 
def create_dummy_file(filename, size_kb, filler=b'A'):
    """
    生成精确大小的测试文件，自动根据扩展名添加文件头
    :param filename: 文件名（扩展名决定类型）
    :param size_kb: 目标大小（KB）
    :param filler: 填充字节（建议非零，避免被压缩）
    """
    target_bytes = size_kb * 1024
    ext = filename.lower().split('.')[-1]
 
    # 标准文件头（最小有效头）
    HEADERS = {
        'png': b'\x89PNG\r\n\x1a\n',
        'jpg': b'\xff\xd8\xff',
        'jpeg': b'\xff\xd8\xff',
        'pdf': b'%PDF-1.7\n%\xe2\xe3\xcf\xd3\n',
        'mp4': b'\x00\x00\x00\x14ftypisom\x00\x00\x02\x00isomiso2avc1mp41',
        'zip': b'PK\x03\x04',
        'gif': b'GIF89a',
        'bmp': b'BM\x00\x00\x00\x00\x00\x00\x00\x00',
    }
 
    header = HEADERS.get(ext, b'')
 
    if len(header) >= target_bytes:
        raise ValueError(f"文件头大小 ({len(header)} 字节) 超过目标文件大小 {target_bytes} 字节，请使用更大的 size_kb")
 
    with open(filename, 'wb') as f:
        f.write(header)
        remaining = target_bytes - len(header)
 
        # 分块写入填充数据
        chunk_size = 64 * 1024
        while remaining > 0:
            block = min(chunk_size, remaining)
            f.write(filler * ((block + len(filler) - 1) // len(filler)))  # 适配任意长度 filler
            f.write(filler[:block])  # 更简单：直接切片
            remaining -= block
 
    actual = os.path.getsize(filename)
    print(f"文件生成: {filename} ({actual} 字节)")
 
 
# =============================
#           主函数
# =============================
def main():
    print("开始生成测试文件...")
 
    # 定义要生成的文件大小（单位：KB）
    sizes_kb = [512, 1024, 3 * 1024, 10 * 1024]  # 512K, 1M, 3M, 10M
    file_prefixes = {
        512: "512k",
        1024: "1m",
        3 * 1024: "3m",
        10 * 1024: "10m"
    }
 
    # 生成每种大小的文件
    for size_kb in sizes_kb:
        prefix = file_prefixes[size_kb]
 
        print(
            f"\n正在生成 {size_kb // 1024 if size_kb >= 1024 else size_kb}{'M' if size_kb >= 1024 else 'K'} 文件...")
 
        # 生成各种格式的文件
        create_pdf_file(f"{prefix}.pdf", size_kb)
        create_png_file(f"{prefix}.png", size_kb)
        create_mp4_file(f"{prefix}.mp4", size_kb)
        create_mp3_file(f"{prefix}.mp3", size_kb)
 
    print("\n所有文件生成完毕！")
 
 
if __name__ == '__main__':
    main()
```

运行：

```bash
python3 gen_pdf.py
```

> ✅ 生成的 PDF 可被浏览器、WPS、Adobe 正常打开

---

### 2. ✅ 生成 MP4 视频文件（使用 FFmpeg）

```bash
# 生成无声视频（纯色画面 + 时间）
ffmpeg -f lavfi -i color=c=black:s=1280x720:d=10 -vf "drawtext=text='Test Video':x=100:y=100:fontsize=24" -b:v 500k -y test_1m.mp4
ffmpeg -f lavfi -i color=c=blue:s=1280x720:d=30 -b:v 800k -y test_2m.mp4
ffmpeg -f lavfi -i color=c=red:s=1920x1080:d=60 -b:v 1500k -y test_3m.mp4
ffmpeg -f lavfi -i color=c=green:s=1920x1080:d=120 -b:v 2000k -y test_5m.mp4
```

> ✅ 生成真实 MP4 文件，可用 VLC、手机播放器打开  
> 🔍 `-b:v` 控制码率，间接控制文件大小

---

### 3. ✅ 生成 MP3 音频文件（使用 FFmpeg 生成静音音频）

```bash
# 生成静音音频（1秒 ≈ 10KB 左右，根据码率调整）
ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -t 60 -b:a 128k -y test_1m.mp3
ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -t 120 -b:a 128k -y test_2m.mp3
ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -t 300 -b:a 128k -y test_5m.mp3
```

> ✅ 生成真实 MP3 文件，可用播放器打开（听到静音或轻微噪音）  
> 💡 你也可以替换为真实音频片段做循环

---

### 4. ✅ 生成 JPG/PNG 图片（使用 ImageMagick）

```bash
convert -size 1000x800 xc:lightgray -fill black -draw "text 300,400 'Test 500K'" -quality 85 test_500k.jpg
convert -size 1600x1200 xc:yellow -fill red -draw "text 500,600 '1M'" -quality 90 test_1m.jpg
convert -size 1920x1080 xc:cyan -fill purple -draw "text 600,540 '2M'" -quality 95 test_2m.jpg
convert -size 2560x1440 xc:magenta -fill white -draw "text 800,720 '3M'" -quality 98 test_3m.jpg
```

---

### 5. ✅ 生成 TXT 文本文件（任意大小）

```bash
# 生成 500KB 文本
yes "This is a test line for performance upload." | head -c 512000 > test_500k.txt

# 生成 1MB 文本
yes "Upload performance test data line." | head -c 1048576 > test_1m.txt
```

---

### 6. ✅ 生成任意二进制文件（私有文件）

```bash
# 使用随机数据填充
dd if=/dev/urandom of=test_private_1m.bin bs=1024 count=1024
dd if=/dev/urandom of=test_private_2m.bin bs=1024 count=2048
```

---

## 🚀 四、一键打包脚本：`gen_test_files.sh`

```bash
#!/bin/bash
echo "🚀 开始生成多类型测试文件..."

mkdir -p test_files/pdf
mkdir -p test_files/image
mkdir -p test_files/video
mkdir -p test_files/audio
mkdir -p test_files/text
mkdir -p test_files/private

# --- PDF ---
python3 -c "
from fpdf import FPDF
pdf = FPDF(); pdf.add_page(); pdf.set_font('Arial', size=12)
for i in range(1000): pdf.cell(0, 5, 'Test PDF Line %d - Performance Upload' % i, ln=True)
pdf.output('test_files/pdf/test_500k.pdf')
" 2>/dev/null || echo "⚠️ 跳过 PDF（需安装 fpdf: pip3 install fpdf）"

# --- Image ---
convert -size 1000x800 xc:lightgray -fill black -draw "text 300,400 '500K'" -quality 85 test_files/image/test_500k.jpg 2>/dev/null || echo "⚠️ 跳过 JPG（需安装 ImageMagick）"
convert -size 1920x1080 xc:blue -fill white -draw "text 600,540 '3M'" -quality 98 test_files/image/test_3m.jpg

# --- Video ---
ffmpeg -f lavfi -i color=c=black:s=1280x720:d=10 -vf \"drawtext=text='Test':x=100:y=100\" -b:v 500k -y test_files/video/test_1m.mp4 2>/dev/null || echo "⚠️ 跳过 MP4（需安装 ffmpeg）"
ffmpeg -f lavfi -i color=c=blue:s=1280x720:d=60 -b:v 1500k -y test_files/video/test_3m.mp4

# --- Audio ---
ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -t 60 -b:a 128k -y test_files/audio/test_1m.mp3 2>/dev/null || echo "⚠️ 跳过 MP3"
ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -t 300 -b:a 128k -y test_files/audio/test_5m.mp3

# --- Text ---
yes "Upload test line." | head -c 512000 > test_files/text/test_500k.txt
yes "Large text for upload test." | head -c 3145728 > test_files/text/test_3m.txt

# --- Private Binary ---
dd if=/dev/urandom of=test_files/private/test_1m.bin bs=1024 count=1024 2>/dev/null
dd if=/dev/urandom of=test_files/private/test_2m.bin bs=1024 count=2048 2>/dev/null

echo "✅ 所有测试文件已生成！"
ls -R test_files/
```

保存为 `gen_test_files.sh`，运行：

```bash
chmod +x gen_test_files.sh
./gen_test_files.sh
```

---

## 📁 五、生成的目录结构示例

```
test_files/
├── pdf/
│   ├── test_500k.pdf
│   └── test_1m.pdf
├── image/
│   ├── test_500k.jpg
│   └── test_3m.jpg
├── video/
│   ├── test_1m.mp4
│   └── test_3m.mp4
├── audio/
│   ├── test_1m.mp3
│   └── test_5m.mp3
├── text/
│   ├── test_500k.txt
│   └── test_3m.txt
└── private/
    ├── test_1m.bin
    └── test_2m.bin
```

---

## ✅ 六、验证文件合法性

```bash
file --mime-type test_files/**/*
```

输出示例：

```
test_files/audio/test_1m.mp3:            audio/mpeg
test_files/image/test_500k.jpg:          image/jpeg
test_files/pdf/test_500k.pdf:            application/pdf
test_files/text/test_500k.txt:           text/plain
test_files/video/test_1m.mp4:            video/mp4
test_files/private/test_1m.bin:          application/octet-stream
```

> ✅ 全部为正确 MIME 类型，可用于真实接口测试！

---

## ✅ 七、在压测脚本中使用

```bash
# 示例：随机上传一个文件
files=(test_files/*/*.jpg test_files/*/*.pdf test_files/*/*.mp4)
file_to_upload="${files[RANDOM % ${#files[@]}]}"

curl -F "file=@$file_to_upload" \
     -H "client_app_id:test_app" \
     http://172.17.60.98:9000/v2/file/upload/stream/public/image
```

---

## ✅ 总结：你现在可以轻松生成

| 类型      | 工具                | 是否真实可用 |
|---------|-------------------|--------|
| PDF     | Python + FPDF     | ✅ 是    |
| MP4     | FFmpeg            | ✅ 是    |
| MP3     | FFmpeg            | ✅ 是    |
| JPG/PNG | ImageMagick       | ✅ 是    |
| TXT     | `yes + head`      | ✅ 是    |
| BIN     | `dd /dev/urandom` | ✅ 是    |

---

📥 **需要我为你打包一个 `.zip` 压缩包，包含：**

- `gen_test_files.sh`
- `gen_pdf.py`
- 示例生成结果（小文件）
- 使用说明？

你可以直接下载运行，快速开始压测。

是否需要？我可以生成完整文件包内容供你复制粘贴。